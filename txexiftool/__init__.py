"""
Twisted protocol for Phil Harvey's exiftool.
"""
from __future__ import absolute_import
from __future__ import division
from __future__ import unicode_literals

import re
from twisted.internet import defer, error, protocol

try:
    from os import fsencode
except ImportError:
    from txexiftool.compat import fsencode


class ExiftoolProtocol(protocol.Protocol):
    """
    A protocol that talks to Phil Harvey's exiftool in batch mode.

    @cvar MAX_LENGTH: The maximum length of a response to allow (If an incoming
                      message is longer than this, the connection is dropped).
                      Default is 65536.
    """

    MAX_LENGTH = 2**16
    _buffer = None
    _pattern = re.compile(b'^{ready([0-9]+)}$', re.MULTILINE)
    _queue = None
    _stopped = None
    _tag = None

    def connectionMade(self):
        """
        Initializes the protocol.
        """
        self._buffer = b''
        self._queue = {}
        self._stopped = None
        self._tag = 0

    def dataReceived(self, data):
        """
        Parses chunks of bytes into responses.

        Whenever a complete response is received, this method extracts its
        payload and calls L{responseReceived} to process it.

        @param data: A chunk of data representing a (possibly partial) response
        @type data: C{bytes}
        """
        size = len(self._buffer) + len(data)
        if size > self.MAX_LENGTH:
            self.lengthLimitExceeded(size)
        self._buffer += data

        start = 0
        for match in self._pattern.finditer(self._buffer):
            # The start of the sentinel marks the end of the response.
            end = match.start()
            tag = int(match.group(1))
            self.responseReceived(self._buffer[start:end], tag)

            # Advance start position to the beginning of the next line
            start = match.end() + 1

        if start:
            self._buffer = self._buffer[start:]

    def responseReceived(self, response, tag):
        """
        Receives some characters of a netstring.

        Whenever a complete response is received, this method calls the
        deferred associated with it.

        @param response: A complete response generated by exiftool.
        @type response: C{bytes}
        @param tag: The tag associated with the response
        @type tag: C{int}
        """
        self._queue.pop(tag).callback(response)

    def lengthLimitExceeded(self, length):
        """
        Callback invoked when the incomming data would exceed the length limit
        appended to the buffer. The default implementation disconnects the
        transport.

        @param length: The total number of bytes
        @type length: C{int}
        """
        self.transport.loseConnection()

    def execute(self, *args):
        """
        Pass one command to exiftool and return a deferred which is fired as
        soon as the command completes.

        @param *args: Command line arguments passed to exiftool
        @type *args: C{unicode}

        @rtype: C{Deferred}
        @return: A deferred whose callback will be invoked when the command
        completed.
        """

        result = defer.Deferred()
        if self.connected and not self._stopped:
            self._tag += 1

            args = tuple(args) + ('-execute{:d}'.format(self._tag), '')
            safe_args = [fsencode(arg) for arg in args]
            self.transport.write(b'\n'.join(safe_args))

            result = defer.Deferred()
            self._queue[self._tag] = result
        else:
            result.errback(error.ConnectionClosed('Not connected to exiftool'))

        return result


    def loseConnection(self):
        """
        Close the connection and terminate the exiftool process.

        @rtype: C{Deferred}
        @return: A deferred whose callback will be invoked when the connection
        was closed.
        """
        if self._stopped:
            result = self._stopped
        elif self.connected:
            result = defer.Deferred()
            self._stopped = result
            self.transport.write(b'\n'.join((b'-stay_open', b'False', b'')))
        else:
            # Already disconnected.
            result = defer.succeed(self)

        return result

    def connectionLost(self, reason=protocol.connectionDone):
        """
        Check whether termination was intended and invoke the deferred.

        If the connection terminated unexpectedly, reraise the failure.

        @type reason: L{twisted.python.failure.Failure}
        """
        self.connected = 0

        for pending in self._queue.values():
            pending.errback(reason)
        self._queue.clear()

        if self._stopped:
            result = self if reason.check(error.ConnectionDone) else reason
            self._stopped.callback(result)
            self._stopped = None
        else:
            reason.raiseException()
